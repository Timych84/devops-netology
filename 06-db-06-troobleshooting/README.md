# Домашнее задание к занятию "6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её
нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
В целом рекомендуется настроить мониторинг MongoDB для более удобного выявления проблем.

Для выявления можно использовать [db.currentOp](
https://www.mongodb.com/docs/manual/reference/method/db.currentOp/#active-operations-on-a-specific-database)


```json
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 }
   }
)
```
Для прерывания использовать [db.killOp](
https://www.mongodb.com/docs/manual/tutorial/terminate-running-operations/#killop)

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Вомзможно стоит попытаться выявить причину долгих запросов,
- использовать MongoDB Profiler
- использовать метод explain

Можно установить лимит с помощью метода  [maxTimeMS](https://www.mongodb.com/docs/manual/tutorial/terminate-running-operations/#maxtimems)


## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL.
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

Если сначала идет рост количества записей по отношению к истекшим, то получается, что наступит момент когда будет очень много записей которые станут устаревшими в один момент.
Исходя из [документации](https://redis.io/docs/management/optimization/latency/#latency-generated-by-expires) получается что в данной ситуации произойдет проблема с латенси в связи с expire.

По умолчанию процесс устаревания происходит каждые 100мс и если найдено более 25% устаревших ключей - повторяется.
Вероятно в данном случае возникла ситуация в который redisk блокирует операции пока количество устаревших ключей не упадет ниже 25%.
Если эта ситуация повторяется постоянно, вероятно есть проблемы с сайзингом системы.

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

Если известно, что сам сервис СУБД доступен и проблемы именно с запросом, то вероятно есть проблемы c запросом или с организацией данных. Если это связано с ростом количества данных, то возможно с большим размером пакета.

[Документация по данной проблеме](
https://dev.mysql.com/doc/refman/8.0/en/gone-away.html)


Если mysqld получает слишком большой пакет(по умолчанию 64МБ), то он предполагает, что есть проблема с клиентом и закрывает соединение. Можно изменить это поведение (задать max_allowed_packet).

[Изменение размера пакета](https://dev.mysql.com/doc/refman/8.0/en/packet-too-large.html)


## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?
Происходит нехватка памяти в ОС и oom-killer завершает процесс PostgreSQL


Как бы вы решили данную проблему?

1. Настройка параметров PostgreSQL (например shared_buffers и work_mem) чтобы привести их в соответствии с количеством памяти на системе.

    [Настройка ресурсов PostgreSQL](https://www.postgresql.org/docs/current/runtime-config-resource.html)


1. При возможности настроить параметры ядра vm.overcommit_memory=2, что может снизить шансы завершения процесса, изменить OOM score для исключения завершения процесса(сомнительно если других процессов на сервере нет)
    [Настройка параметров ядра](https://www.postgresql.org/docs/current/kernel-resources.html#LINUX-MEMORY-OVERCOMMIT)
1. Если нехватка памяти не связана с неправильной настройкой - увеличить количество памяти на сервере или переделывать архитектуру приложения для распределения нагрузки

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
